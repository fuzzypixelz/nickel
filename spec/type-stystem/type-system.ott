% NICKEL
metavar var, x, y, z ::=
metavar labels, l, l' ::=
metavar typevar, a {{ tex \alpha }}, b {{ tex \beta }}, c {{ tex \gamma }} ::=
metavar rowvar, A {{ tex \theta }}, B {{ tex \iota }}, C {{ tex \kappa }} ::=
indexvar i, j, k, n, m ::=

grammar
rows_notail {{ tex \rho }} :: 'rows_notail_' ::=
 | empty                   ::  :: Empty
 | rows_notail , l : t     ::  :: Cons
 | l1 : t1 , .. , ln : tn  ::  :: Rows

rows_enum_notail {{ tex \chi }} :: 'rows_enum_notail_' ::=
 | empty           ::  :: Empty
 | rows_enum_notail , l ::  :: Cons
 | l1 , .. , ln     ::  :: Rows

rows :: 'rows_' ::=
 | rows_notail         ::   :: NoTail
 | rows_notail '|' A   ::   :: Tail
 | rows_notail '|' Dyn ::   :: DynTail

rows_enum :: 'rows_enum_' ::=
 | rows_enum_notail       ::   :: NoTail
 | rows_enum_notail '|' A ::   :: Tail

t_mono {{ tex \rho }} :: 't_mono_' ::=
 | Dyn                        ::   :: Dyn
 | a                          ::   :: TypeVar
 | A                          ::   :: RowVar
 | t1 -> t2                   ::   :: Fun
 | { rows }                   ::   :: Record
 | { _ : t }                  ::   :: DynRecord
 | < rows_enum >              ::   :: Enum
 | Array t                    ::   :: Array
 | # e                        ::   :: Contract
 | ( t_mono )                 :: S :: Parens
 | t_mono [ t_mono' / a ]     :: M :: Subst
 | t_mono [ rows / A ]        :: M :: SubstRow

t {{ tex \sigma }}, u {{ tex \tauÂ }} :: 't_' ::=
 | Dyn                        ::   :: Dyn
 | a                          ::   :: TypeVar
 | A                          ::   :: RowVar
 | t1 -> t2                   ::   :: Fun
 | { rows }                   ::   :: Record
 | { _ : t }                  ::   :: DynRecord
 | < rows_enum >              ::   :: Enum
 | Array t                    ::   :: Array
 | # e                        ::   :: Contract
 | forall a1 ... an . t       ::   :: Forall
 | forall A1 ... An . t       ::   :: ForallRow
 | ( t )                      :: S :: Parens
 | t [ u / a ]                :: M :: Subst
 | t [ rows / A ]             :: M :: SubstRow

e :: 'e_' ::=
 | null                                       ::   :: Null
 | x                                          ::   :: Var
 | h e1 ... en                                ::   :: App
 | e . l                                      ::   :: Proj
 | head e                                     ::   :: Head
 | tail e                                     ::   :: Tail
 | \ x . e                                    ::   :: Abs
 | let pat = e1 in e2                         ::   :: Let
 | case e of {l1 <- e1, .., ln <- en}         ::   :: Case
 | ` l                                        ::   :: Enum
 | { l1 = e1 , .. , ln = en }                 ::   :: Record
 | [ e1 , .. , en ]                           ::   :: Array
 | e : t                                      ::   :: Annot
 | e @ t                                      ::   :: Contract
 | ( e )                                      :: S :: Parens
 | e [ e' / x ]                               :: M :: Subst

h :: 'h_' ::=
 | null                                       ::   :: Null
 | x                                          ::   :: Var
 | e . l                                      ::   :: Proj
 | head e                                     ::   :: Head
 | tail e                                     ::   :: Tail
 | \ x . e                                    ::   :: Abs
 | let pat = e1 in e2                         ::   :: Let
 | case e of {l1 <- e1, .., ln <- en}         ::   :: Case
 | ` l                                        ::   :: Enum
 | { l1 = e1 , .. , ln = en }                 ::   :: Record
 | [ e1 , .. , en ]                           ::   :: Array
 | e : t                                      ::   :: Annot
 | e @ t                                      ::   :: Contract
 | ( h )                                      :: S :: Parens

value, v :: 'v_' ::=
  | \ x . e                    ::   :: Abs
  | null                       ::   :: Null
  | { l1 = v1 , .. , ln = vn } ::   :: Record
  | [ v1 , .. , vn ]           ::   :: Array
  | ` l                        ::   :: Enum

whnf, w :: 'w_' ::=
 | \ x . e                    ::   :: Abs
 | null                       ::   :: Null
 | ` l                        ::   :: Enum
 | { l1 = e1 , .. , ln = en } ::   :: Record
 | [ e1 , .. , en ]           ::   :: Array

pat :: 'pat_' ::=
 | x                               ::   :: Var
% | { l1 = pat1 , .. , ln = patn } ::   :: Record
% | [ pat1 , .., patn ]            ::   :: Array

binding :: 'bnd_' ::=
 | x1 : t1 , .. , xn : tn ::  :: Vars

G {{ tex \Gamma }} :: 'ctx_' ::=
 | empty        ::  :: nil
 | G , binding  ::  :: cons {{ tex \Gamma, [[binding]] }}

typebinding :: 'typebinding_' ::=
 | a                                :: :: Var
 | A                                :: :: RowVar
 | typebinding1 , .. , typebindingn :: :: Bindings

Psi {{ tex \Psi }} :: 'typectx_' ::=
 | empty             ::  :: nil
 | Psi , typebinding ::  :: cons {{ tex \Psi, [[typebinding]] }}

grammar
formula :: 'formula_' ::=
 | judgement              :: :: judgement
 | binding set_in G       :: :: binding
 | typebinding set_in Psi :: :: typebinding
 | n <= m                 :: :: inequality
 | t is_not_var           :: :: type_not_var

terminals :: 'terminals_' ::=
 | ->               ::  :: Arrow  {{ tex \to }}
 | <-               ::  :: BindingArrow {{ tex \leftarrow }}
 | \                ::  :: Lambda {{ tex \lambda }}
 | forall           ::  :: Forall {{ tex \forall }}
 | |-               ::  :: Entails {{ tex \vdash }}
 | infers           ::  :: infers {{ tex {\color{red}\Rightarrow} }}
 | infers_head      ::  :: infers_head {{ tex {\color{red}\Rightarrow}^h }}
 | checks           ::  :: checks {{ tex {\color{blue}\Leftarrow} }}
 | checks_poly      ::  :: checks_poly {{ tex {\color{blue}\Leftarrow}^\forall }}
 | inst_as          ::  :: inst_as {{ tex \rightsquigarrow }}
 | has_type         ::  :: HasType {{ tex {:} }}
 | set_in           ::  :: In       {{ tex \in }}
 | -->              ::  :: Eval     {{ tex \longrightarrow }}
 | rest             ::  :: Ellipsis {{ tex \ldots }}
 | '|'              ::  :: RowTail  {{ tex \mid }}
 | @                ::  :: Contract {{ tex \mathbin{@} }}
 | <=               ::  :: LessOrEq {{ tex \leq }}
 | is_not_var       ::  :: IsNotVar {{ tex \text{not a variable} }}

subrules
  t_mono <:: t
  v <:: e
  h <:: e
  whnf <:: e

defns
Jstlc :: '' ::=

defn
Psi |- t1 <: t2 :: :: subtyping :: Sub_
by

a set_in Psi
------------ :: ReflVar
Psi |- a <: a

A set_in Psi
------------ :: ReflRowVar
Psi |- A <: A 

--------------------------------------------------- :: ReflForall
Psi |- forall a1 ... an . t <: forall a1 ... an . t

--------------------------------------------------- :: ReflForallRow
Psi |- forall A1 ... An . t <: forall A1 ... An . t


Psi |- t3 <: t1
Psi |- t2 <: t4
--------------------------- :: Arrow
Psi |- t1 -> t2 <: t3 -> t4


t is_not_var
--------------- :: Dyn
Psi |- t <: Dyn

Psi |- t <: u
--------------------------------------- :: Array
Psi |- Array t <: Array u

Psi |- t <: u
--------------------------------------- :: DynRecord1
Psi |- {_ : t} <: {_ : u}

Psi |- ti <: ui
-------------------------------------------------------- :: Record
Psi |- { l1 : t1, .., ln : tn} <: { l1 : u1, .., ln: un}

Psi |- ti <: ui
------------------------------------------------------------------------------------------ :: DynTail
Psi |- { l1 : t1, .. , ln : tn, l'1 : t'1, .., l'm : t'm } <: { l1 : u1, .., ln: un | Dyn }

Psi |- ti <: u
--------------------------------------- :: DynRecord2
Psi |- { l1 : t1, .., ln : tn} <: {_ : u}

%Psi |- u
%Psi |- t1[u/a] <: t2
%------------------------- :: ForallLeft
%Psi |- forall a. t1 <: t2
%
%%Psi |- {rows}'
%Psi |- t1[rows/A] <: t2
%------------------------- :: ForallRowLeft
%Psi |- forall A. t1 <: t2
%
%Psi, a |- t1 <: t2
%------------------------- :: ForallRight
%Psi |- t1 <: forall a. t2

%Psi, A |- t1 <: t2
%------------------------- :: ForallRowRight
%Psi |- t1 <: forall A. t2

defn
G |- e has_type t :: :: type :: T_
  {{ com Well-typed expressions }}
by

x : t set_in G
----------------- :: Var
G |- x has_type t

G, x : t1 |- e has_type t2
--------------------------- :: Abs
G |- \x.e has_type t1 -> t2

%G |- e1 has_type t1 -> t2
%G |- e2 has_type t1
%------------------------- :: App
%G |- e1 e2 has_type t2

G |- e1 has_type t1
G, x : t1 |- e2 has_type t2
--------------------------------- :: Let
G |- let x = e1 in e2 has_type t2

G |- e has_type t
--------------------------- :: Gen
G |- e has_type forall a. t

G |- e has_type t
--------------------------- :: GenRow
G |- e has_type forall A. t

G |- e has_type forall a. t
--------------------------- :: Inst
G |- e has_type t[u'/a]

G |- e has_type forall A. t
----------------------------- :: InstRow
G |- e has_type t[rows/A]

G |- ei has_type ti
----------------------------------------------------------- :: RecordI
G |- {l1 = e1, .., ln = en} has_type {l1 : t1, .., ln : tn}

G |- ei has_type t
------------------------------------------- :: DynRecordI
G |- {l1 = e1, .., ln = en} has_type {_: t}

G |- e has_type {l1 : t1, .., ln : tn}
-------------------------------------- :: Proj
G |- e.li has_type ti

G |- e has_type {_ : t}
-------------------------------------- :: DynProj
G |- e.l has_type t

G |- e has_type <l1, .., ln>
G |- ei has_type t
----------------------------------------------------------- :: Case
G |- case e of {l1 <- e1, .., ln <- en} has_type t

G |- ei has_type t
--------------------------------- :: ArrayI
G |- [e1, .., en] has_type Array t

G |- e has_type Array t
---------------------- :: Head
G |- head e has_type t

G |- e has_type Array t
--------------------------- :: Tail
G |- tail e has_type Array t

G |- e has_type t
----------------------- :: Annot
G |- (e : t) has_type t

------------------- :: Dyn
G |- e has_type Dyn

% Should we put include the row weakening/embeding here, directly? Or use a
% widening subtyping? I think we want to avoid widening, because it is really a
% non-trivial phenomenon with respect to subtyping: without other subtyping
% rules (beside standard arrow, covariance, etc.), it already makes the
% subtyping relation non-trivial (!= identity).

----------------------- :: Enum
G |- ` l has_type <l, l1, .., ln>

--------------------- :: Contract
G |- e @ t has_type t

defn
G |- h infers_head t :: :: infers_head :: BidirInfHead_
  by

x : t set_in G
-------------------- :: Var
G |- x infers_head t

G |- e infers {l1 : t1, .., ln : tn}
-------------------------------------- :: Proj
G |- e.li infers_head ti

G |- e infers {_: t}
---------------------- :: DynProj
G |- e.l infers_head t

%G |- e checks <l1, .., ln>
%G |- ei infers t
%------------------------------------------------ :: Case
%G |- case e of {l1 <- e1, .., ln <- en} infers t

G |- e infers Array t
----------------------- :: Head
G |- head e infers_head t

G |- e infers Array t
------------------------------- :: Tail
G |- tail e infers_head Array t

G |- e checks t
-------------------------- :: Annot
G |- (h : t) infers_head t

-------------------------- :: Contract
G |- e @ t infers_head t

G |- h infers t_mono
------------------------- :: Infer
G |- h infers_head t_mono

defn
G |- e infers t :: :: infers :: BidirInf_
  by

G |- h e1 .. en inst_as t1, .., tn, t_mono
G |- ei checks ti
-------------------------------------------- :: App
G |- h e1 .. en infers t_mono

%G |- e1 inst_as t1 -> t2
%G |- e2 checks t1
%------------------ :: AppInst
%G |- e1 e2 infers t2

%G |- e infers {l1 : t1, .., ln : tn}
%------------------------------------ :: Proj
%G |- e.li infers ti

%G |- e infers {_: t}
%------------------------------------ :: DynProj
%G |- e.l infers t

G |- e checks <l1, .., ln>
G |- ei infers t_mono
----------------------------------------------------- :: Case
G |- case e of {l1 <- e1, .., ln <- en} infers t_mono

%G |- e infers Array t
%--------------------- :: Head
%G |- head e infers t
%
%G |- e infers Array t
%-------------------------- :: Tail
%G |- tail e infers Array t

%G |- e checks t
%--------------------- :: Annot
%G |- (e : t) infers t

%------------------- :: Contract
%G |- e @ t infers t

-------------------- :: Null
G |- null infers Dyn

defn
G |- e checks t :: :: checks :: BidirCheck_
  by

G |- e checks t_mono
-------------------------------------- :: Gen
G |- e checks forall a1 ... an. t_mono

G |- e checks t_mono
-------------------------------------- :: GenRow
G |- e checks forall A1 ... An. t_mono

G, x : t1 |- e checks t2
------------------------- :: Abs
G |- \x.e checks t1 -> t2

G |- e1 infers t
G, x : t |- e2 checks t_mono
----------------------------------- :: Let
G |- let x = e1 in e2 checks t_mono

G |- e checks <l1, .., ln>
G |- ei checks t_mono
----------------------------------------------------- :: Case
G |- case e of {l1 <- e1, .., ln <- en} checks t_mono

G |- ei checks ti
-------------------------------------------------------- :: Record
G |- {l1 = e1, .., ln = en} checks {l1 : t1, .., ln : tn}

G |- ei checks t
------------------------------------------- :: DynRecord
G |- {l1 = e1, .., ln = en} checks {_: t}

G |- ei checks t
------------------------------ :: Array
G |- [e1, .., en] checks Array t

G |- e infers t_mono1
Psi |- t_mono1 <: t_mono2
------------------------- :: Sub
G |- e checks t_mono2

defn
G |- e inst_as t1, .., tn, t_mono :: :: inst_as :: BidirInst_
  by

%defn
%e --> e' :: :: Jeval :: E_
% {{ com Small-step reduction }}
%by
%
%e --> e'
%-------------- :: App1
%e e2 --> e' e2
%
%----------------------- :: AppAbs
%(\x.e1) e2 --> e1[e2/x]
